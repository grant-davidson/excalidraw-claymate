{"version":3,"sources":["exportToGif.ts","exportToHtml.ts","AnimateConfig.tsx","Claymate.tsx","creation.ts","persistence.ts","useScenes.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["exportToGif","scenes","Promise","resolve","gif","GIF","forEach","scene","index","last","length","addFrame","imageData","delay","on","blob","fileSave","fileName","then","render","exportToHtml","options","a","html","svg","exportToSvg","drawing","animate","animateSvg","elements","filter","element","isDeleted","id","style","display","outerHTML","Blob","type","extractNumberFromId","key","match","RegExp","undefined","Number","applyNumberInId","ids","value","selectedElementIds","appState","map","newId","includes","replace","AnimateConfig","animateEnabled","setAnimateEnabled","updateDrawing","selectedIds","Object","keys","some","animateOrderSet","Set","add","animateOrderDisabled","size","animateDurationSet","animateDurationDisabled","className","checked","onChange","x","opacity","disabled","values","next","e","Math","floor","target","isFinite","width","placeholder","Preview","memo","ref","useRef","useEffect","current","ctx","getContext","putImageData","height","Claymate","currentIndex","updateScenes","moveToScene","addScene","useState","showAnimateConfig","setShowAnimateConfig","exportGif","exportHtml","testId","isEmpty","onClick","data-testid","aria-label","event","stopPropagation","findIndex","sc","remainingScenes","newCurrent","deletingCurrentScene","sourceIndex","prev","item","deleteScene","tmp","moveLeft","moveRight","reverse","createScene","canvas","exportToCanvas","nanoid","getImageData","loadStorage","firstScene","drawings","JSON","parse","localStorage","getItem","collaborators","Map","data","loadDrawingFromStorage","useScenes","initialised","setInitialised","drawingVersion","setDrawingVersion","setCurrentIndex","setScenes","setDrawing","initialScenes","result","stringify","s","setItem","saveStorage","requiredWidth","requiredHeight","onRestore","useCallback","version","updater","currentScene","isEqual","update","el","initialData","App","excalidrawRef","updateScene","Boolean","window","location","hostname","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.6e2e75c2.chunk.js","sourcesContent":["import { fileSave } from \"browser-fs-access\";\n// @ts-ignore\nimport GIF from \"gif.js/dist/gif\";\n\nimport { Scene } from \"./types\";\n\nexport const exportToGif = (scenes: Scene[]) =>\n  new Promise((resolve) => {\n    const gif = new GIF();\n    scenes.forEach((scene, index) => {\n      const last = index + 1 === scenes.length;\n      gif.addFrame(scene.imageData, { delay: last ? 2000 : 500 });\n    });\n    gif.on(\"finished\", (blob: Blob) => {\n      fileSave(blob, {\n        fileName: \"excalidraw-claymate.gif\",\n      }).then(resolve);\n    });\n    gif.render();\n  });\n","import { fileSave } from \"browser-fs-access\";\nimport { exportToSvg } from \"@excalidraw/excalidraw\";\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\nimport { animateSvg } from \"excalidraw-animate/dist/library\";\n\nimport { Scene } from \"./types\";\n\nconst getNonDeletedElements = (\n  elements: readonly ExcalidrawElement[]\n): NonDeletedExcalidrawElement[] =>\n  elements.filter(\n    (element): element is NonDeletedExcalidrawElement => !element.isDeleted\n  );\n\ntype Options = {\n  animate?: boolean;\n};\n\nexport const exportToHtml = async (scenes: Scene[], options: Options) => {\n  let html = `<!DOCTYPE html>\n    <html lang=\"en\">\n      <style>\n        svg { width: 100%; height: 100%; }\n        body { margin: 0px; font-size: 24px; }\n        button { background: transparent; border: none; cursor: pointer; padding: 3px; margin: 0px 10px; font-size: inherit;}\n        #container { display: flex; flex-direction: column; height: 100%; }\n        #navigation { display: flex; justify-content: center; align-items: center; padding: 5px; border-top: 1px solid lightgray; background: white; }        \n        #rightbuttons { position: absolute; right: 10px; display: flex;  }\n        #slides { height: calc(100vh - 50px); }                \n      </style>\n      <script>\n        let index = 0;\n        let totalScenes = ${scenes.length}\n        function updateTitle() {\n          document.getElementById('title').innerText = '' + (index + 1) + ' of ' + totalScenes;\n        }\n        function moveLeft() {\n          if (index > 0) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index -= 1;\n            document.getElementById('scene' + index).style.display = 'block';\n            updateTitle();\n            document.getElementById('scene' + index).setCurrentTime(0);\n          }\n        }\n        function moveRight() {\n          if (index < totalScenes - 1) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index += 1;\n            document.getElementById('scene' + index).style.display = 'block';\n            updateTitle();\n            document.getElementById('scene' + index).setCurrentTime(0);\n          }\n        }\n        function closeNavigation() {\n          document.getElementById('navigation').style.display = 'none';\n          document.getElementById('slides').style.height = '100vh'\n        }\n        function toggleMaximise() {\n          if (document.fullscreenElement === document.body) {\n            document.exitFullscreen();\n          } else {\n            document.body.requestFullscreen();\n          }\n        }\n        document.addEventListener('DOMContentLoaded', () => {\n          document.getElementById('scene' + index).style.display = 'block';\n          document.getElementById('scene' + index).setCurrentTime(0);\n        });\n        document.addEventListener('keydown', (event) => {\n          if (event.key === 'ArrowRight') {\n            moveRight();\n          }\n          if (event.key === 'ArrowLeft') {\n            moveLeft();\n          }\n          if (event.key.toLowerCase() === 'f') {\n            toggleMaximise();            \n          }\n        });\n      </script>\n      <body>\n      <div id=\"container\">\n      <div id=\"slides\">\n  `;\n  scenes.forEach((scene, index) => {\n    const svg: SVGSVGElement = exportToSvg(scene.drawing);\n    if (options.animate) {\n      animateSvg(svg, getNonDeletedElements(scene.drawing.elements));\n    }\n    svg.id = `scene${index}`;\n    svg.style.display = \"none\";\n    html += svg.outerHTML;\n  });\n  html += `</div>\n            <div id=\"navigation\">\n              <button class=\"navbutton\" type=\"button\" onClick=\"moveLeft()\" title=\"Previous slide\">&#9664;</button>\n              <div id=\"title\">1 of ${scenes.length}</div>\n              <button class=\"navbutton\" type=\"button\" onClick=\"moveRight()\" title=\"Next slide\">&#9654;</button>          \n              <div id=\"rightbuttons\">\n                <button type=\"button\" onClick=\"toggleMaximise()\" title=\"Toggle full-screen\">&#x26F6;</button>\n                <button type=\"button\" onClick=\"closeNavigation()\" title=\"Close this panel\">&#x2716;</button>\n              <div>\n            </div>\n        </div></body></html>`;\n  await fileSave(new Blob([html], { type: \"text/html\" }), {\n    fileName: \"excalidraw-claymate.html\",\n  });\n};\n","import React, { ChangeEvent, Dispatch, SetStateAction } from \"react\";\n\nimport \"./AnimateConfig.css\";\nimport { Drawing, Scene } from \"./types\";\n\nconst extractNumberFromId = (id: string, key: string) => {\n  const match = id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return match === null ? undefined : Number(match[1]) || 0;\n};\n\nconst applyNumberInId = (\n  drawing: Drawing,\n  ids: string[],\n  key: string,\n  value: number\n): Drawing => {\n  const selectedElementIds = { ...drawing.appState.selectedElementIds };\n  const elements = drawing.elements.map((element) => {\n    const { id } = element;\n    if (!ids.includes(id)) {\n      return element;\n    }\n    let newId: string;\n    const match = id.match(new RegExp(`${key}:(-?\\\\d+)`));\n    if (match) {\n      newId = id.replace(new RegExp(`${key}:(-?\\\\d+)`), `${key}:${value}`);\n    } else {\n      newId = id + `-${key}:${value}`;\n    }\n    if (id === newId) {\n      return element;\n    }\n    selectedElementIds[newId] = selectedElementIds[id];\n    delete selectedElementIds[id];\n    return { ...element, id: newId };\n  });\n  return {\n    elements,\n    appState: {\n      ...drawing.appState,\n      selectedElementIds,\n    },\n  };\n};\n\ntype Props = {\n  animateEnabled: boolean;\n  setAnimateEnabled: Dispatch<SetStateAction<boolean>>;\n  scene: Scene | undefined;\n  updateDrawing: (drawing: Drawing) => void;\n};\n\nconst AnimateConfig: React.FC<Props> = ({\n  animateEnabled,\n  setAnimateEnabled,\n  scene,\n  updateDrawing,\n}) => {\n  const elements = scene?.drawing.elements ?? [];\n  const selectedIds = scene\n    ? Object.keys(scene.drawing.appState.selectedElementIds ?? {}).filter(\n        (id) =>\n          scene.drawing.appState.selectedElementIds[id] &&\n          elements.some((element) => element.id === id)\n      )\n    : [];\n\n  const animateOrderSet = new Set<number | undefined>();\n  selectedIds.forEach((id) => {\n    animateOrderSet.add(extractNumberFromId(id, \"animateOrder\"));\n  });\n  const onChangeAnimateOrder = (e: ChangeEvent<HTMLInputElement>) => {\n    const value = Math.floor(Number(e.target.value));\n    if (scene && Number.isFinite(value)) {\n      updateDrawing(\n        applyNumberInId(scene.drawing, selectedIds, \"animateOrder\", value)\n      );\n    }\n  };\n  const animateOrderDisabled = !animateEnabled || !animateOrderSet.size;\n\n  const animateDurationSet = new Set<number | undefined>();\n  selectedIds.forEach((id) => {\n    animateDurationSet.add(extractNumberFromId(id, \"animateDuration\"));\n  });\n  const onChangeAnimateDuration = (e: ChangeEvent<HTMLInputElement>) => {\n    const value = Math.floor(Number(e.target.value));\n    if (scene && Number.isFinite(value)) {\n      updateDrawing(\n        applyNumberInId(scene.drawing, selectedIds, \"animateDuration\", value)\n      );\n    }\n  };\n  const animateDurationDisabled = !animateEnabled || !animateDurationSet.size;\n\n  return (\n    <div className=\"AnimateConfig\">\n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={animateEnabled}\n            onChange={() => setAnimateEnabled((x) => !x)}\n          />\n          Enable animate\n        </label>\n      </div>\n      <div style={{ opacity: animateOrderDisabled ? 0.3 : 1.0 }}>\n        Animate order:{\" \"}\n        {animateOrderSet.size > 1 ? (\n          <>(mixed)</>\n        ) : (\n          <input\n            disabled={animateOrderDisabled}\n            value={\n              (animateOrderSet.size === 1 &&\n                animateOrderSet.values().next().value) ||\n              0\n            }\n            onChange={onChangeAnimateOrder}\n            type=\"number\"\n            style={{ width: 40 }}\n          />\n        )}\n      </div>\n      <div style={{ opacity: animateDurationDisabled ? 0.3 : 1.0 }}>\n        Animate duration (ms):{\" \"}\n        {animateDurationSet.size > 1 ? (\n          <>(mixed)</>\n        ) : (\n          <input\n            disabled={animateDurationDisabled}\n            value={\n              (animateDurationSet.size === 1 &&\n                animateDurationSet.values().next().value) ||\n              \"\"\n            }\n            onChange={onChangeAnimateDuration}\n            placeholder=\"Default\"\n            style={{ width: 50 }}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default AnimateConfig;\n","import React, { memo, useState, useEffect, useRef } from \"react\";\nimport { isEmpty } from \"lodash\";\n\nimport \"./Claymate.css\";\nimport { Drawing, Scene } from \"./types\";\nimport { exportToGif } from \"./exportToGif\";\nimport { exportToHtml } from \"./exportToHtml\";\nimport AnimateConfig from \"./AnimateConfig\";\n\nconst Preview = memo<{ scene: Scene }>(({ scene }) => {\n  const ref = useRef<HTMLCanvasElement>(null);\n  useEffect(() => {\n    if (!ref.current) return;\n    const ctx = ref.current.getContext(\"2d\");\n    if (!ctx) return;\n    ctx.putImageData(scene.imageData, 0, 0);\n  }, [scene]);\n  return <canvas ref={ref} width={scene.width} height={scene.height} />;\n});\n\ntype Props = {\n  currentIndex: number | undefined;\n  scenes: Scene[];\n  updateScenes: (\n    updater: (prev: Scene[]) => Scene[],\n    newCurrent?: { index: number; drawing: Drawing }\n  ) => void;\n  moveToScene: (index: number) => void;\n  addScene: () => void;\n  updateDrawing: (drawing: Drawing) => void;\n};\n\nconst Claymate: React.FC<Props> = ({\n  scenes,\n  currentIndex,\n  updateScenes,\n  moveToScene,\n  addScene,\n  updateDrawing,\n}) => {\n  const [showAnimateConfig, setShowAnimateConfig] = useState(false);\n  const [animateEnabled, setAnimateEnabled] = useState(false);\n\n  const exportGif = async () => {\n    await exportToGif(scenes);\n  };\n\n  const exportHtml = async () => {\n    await exportToHtml(scenes, { animate: animateEnabled });\n  };\n\n  const deleteScene = (id: string) => {\n    const index = scenes.findIndex((sc) => sc.id === id);\n    if (index >= 0) {\n      const remainingScenes = scenes.length - 1;\n      if (remainingScenes > 0) {\n        let newCurrent;\n        if (currentIndex !== undefined) {\n          const deletingCurrentScene = index === currentIndex;\n          if (currentIndex > index || deletingCurrentScene) {\n            let sourceIndex = currentIndex;\n            if (deletingCurrentScene) {\n              if (currentIndex === remainingScenes) {\n                sourceIndex = currentIndex - 1;\n              } else if (currentIndex === 0) {\n                sourceIndex = 1;\n              }\n            }\n            newCurrent = {\n              index: currentIndex > 0 ? currentIndex - 1 : currentIndex,\n              drawing: scenes[sourceIndex].drawing,\n            };\n          }\n        }\n        updateScenes(\n          (prev: Scene[]) => prev.filter((item) => item.id !== id),\n          newCurrent\n        );\n      }\n    }\n  };\n\n  const moveLeft = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index - 1] = prev[index];\n        tmp[index] = prev[index - 1];\n        return tmp;\n      },\n      { index: index - 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const moveRight = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index + 1] = prev[index];\n        tmp[index] = prev[index + 1];\n        return tmp;\n      },\n      { index: index + 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const reverseOrder = () => {\n    updateScenes(\n      (prev) => [...prev].reverse(),\n      currentIndex !== undefined\n        ? {\n            index: scenes.length - 1 - currentIndex,\n            drawing: scenes[currentIndex].drawing,\n          }\n        : undefined\n    );\n  };\n\n  useEffect(() => {\n    if (scenes.length === 0) {\n      addScene();\n    }\n  }, [scenes, addScene]);\n\n  return (\n    <div className=\"Claymate\">\n      <div className=\"Claymate-scenes\">\n        {scenes.map((scene, index) => {\n          let testId = \"MissingId\";\n          if (!isEmpty(scenes[index].drawing.elements)) {\n            testId = scenes[index].drawing.elements[0].id;\n          }\n          return (\n            <div\n              key={scene.id}\n              className={`Claymate-scene ${\n                index === currentIndex ? \"Claymate-current-scene\" : \"\"\n              }`}\n              onClick={() => moveToScene(index)}\n              data-testid={testId}\n            >\n              <Preview scene={scene} />\n              <button\n                type=\"button\"\n                className=\"Claymate-delete\"\n                aria-label=\"Delete\"\n                disabled={scenes.length <= 1}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  deleteScene(scene.id);\n                }}\n              >\n                &#x2716;\n              </button>\n              <button\n                type=\"button\"\n                className=\"Claymate-left\"\n                aria-label=\"Move Left\"\n                disabled={index === 0}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  moveLeft(scene.id);\n                }}\n              >\n                &#x2b05;\n              </button>\n              <button\n                type=\"button\"\n                className=\"Claymate-right\"\n                aria-label=\"Move Right\"\n                disabled={index === scenes.length - 1}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  moveRight(scene.id);\n                }}\n              >\n                &#x27a1;\n              </button>\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"Claymate-configs\">\n        {showAnimateConfig && (\n          <AnimateConfig\n            animateEnabled={animateEnabled}\n            setAnimateEnabled={setAnimateEnabled}\n            scene={\n              currentIndex === undefined ? undefined : scenes[currentIndex]\n            }\n            updateDrawing={updateDrawing}\n          />\n        )}\n      </div>\n      <div className=\"Claymate-buttons\">\n        <button type=\"button\" onClick={addScene}>\n          Add scene\n        </button>\n        <button\n          type=\"button\"\n          onClick={exportGif}\n          disabled={scenes.length === 0}\n        >\n          Export GIF\n        </button>\n        <div>\n          <button type=\"button\" onClick={() => setShowAnimateConfig((x) => !x)}>\n            {showAnimateConfig ? <>&#9656;</> : <>&#9666;</>}\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => exportHtml()}\n            disabled={scenes.length === 0}\n          >\n            Export HTML\n          </button>\n        </div>\n        <button\n          type=\"button\"\n          onClick={reverseOrder}\n          disabled={scenes.length <= 1}\n        >\n          Reverse order\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Claymate;\n","import { nanoid } from \"nanoid\";\nimport { exportToCanvas } from \"@excalidraw/excalidraw\";\nimport { Drawing, Scene } from \"./types\";\n\nexport const createScene = (\n  drawing: Drawing,\n  size?: { width: number; height: number }\n): Scene | undefined => {\n  const canvas = exportToCanvas({ elements: drawing.elements });\n  const width = size ? size.width : canvas.width;\n  const height = size ? size.height : canvas.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    return {\n      id: nanoid(),\n      width,\n      height,\n      imageData: ctx.getImageData(0, 0, width, height),\n      drawing,\n    };\n  }\n};\n","import { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\n\nconst ELEMENTS_STORAGE_KEY = \"excalidraw-elements\";\nconst SCENE_STORAGE_KEY = \"claymate-scenes\";\n\nconst loadDrawingFromStorage = (): Drawing | null => {\n  try {\n    const data = JSON.parse(localStorage.getItem(ELEMENTS_STORAGE_KEY) || \"\");\n    data.appState.collaborators = new Map();\n    return data;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const loadStorage = (): Scene[] | null => {\n  try {\n    const drawings = JSON.parse(\n      localStorage.getItem(SCENE_STORAGE_KEY) || \"\"\n    ) as Drawing[];\n    if (drawings && drawings.length > 0) {\n      let firstScene: Scene | undefined;\n      return drawings.map((drawing) => {\n        drawing.appState.collaborators = new Map();\n        const scene = createScene(\n          drawing,\n          firstScene\n            ? { width: firstScene.width, height: firstScene.height }\n            : undefined\n        );\n        if (firstScene === undefined) {\n          firstScene = scene;\n        }\n        return scene;\n      }) as Scene[];\n    }\n  } catch {\n    try {\n      const drawing = loadDrawingFromStorage();\n      if (drawing) {\n        const scene = createScene(drawing);\n        if (scene) {\n          return [scene];\n        }\n      }\n    } catch {}\n  }\n  return null;\n};\n\nexport const saveStorage = (scenes: Scene[]) => {\n  const result = JSON.stringify(scenes.map((s) => s.drawing));\n  localStorage.setItem(SCENE_STORAGE_KEY, result);\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { AppState } from \"@excalidraw/excalidraw/types/types\";\nimport { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\nimport isEqual from \"lodash/isEqual\";\nimport { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\nimport { loadStorage, saveStorage } from \"./persistence\";\n\nexport const useScenes = () => {\n  const [initialised, setInitialised] = useState(false);\n  const [drawingVersion, setDrawingVersion] = useState(0);\n  const [currentIndex, setCurrentIndex] = useState<number | undefined>(0);\n  const [scenes, setScenes] = useState<Scene[]>([]);\n  const [drawing, setDrawing] = useState<Drawing | undefined>();\n\n  useEffect(() => {\n    if (!initialised) {\n      const initialScenes = loadStorage();\n      if (initialScenes && initialScenes.length > 0) {\n        setScenes(initialScenes);\n        setCurrentIndex(0);\n        setDrawing(initialScenes[0].drawing);\n      }\n    }\n  }, [initialised, setInitialised]);\n\n  useEffect(() => {\n    saveStorage(scenes);\n  }, [scenes]);\n\n  const onRestore = useCallback((drawing: Drawing) => {\n    setDrawingVersion((version) => version + 1);\n    setDrawing(drawing);\n  }, []);\n\n  const moveToScene = useCallback(\n    (index: number) => {\n      onRestore(scenes[index].drawing);\n      setCurrentIndex(index);\n    },\n    [onRestore, setCurrentIndex, scenes]\n  );\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState\n  ) => {\n    if (\n      drawing == null ||\n      !isEqual(elements, drawing.elements) ||\n      !isEqual(appState, drawing.appState)\n    ) {\n      const update = {\n        elements: elements.map((el) => {\n          return { ...(el as any) };\n        }),\n        appState: { ...(appState as any) },\n      };\n      setDrawing(update);\n    }\n  };\n\n  const updateScenes = useCallback(\n    (\n      updater: (prev: Scene[]) => Scene[],\n      newCurrent?: { index: number; drawing: Drawing }\n    ) => {\n      setScenes(updater);\n      if (newCurrent) {\n        onRestore(newCurrent.drawing);\n        setCurrentIndex(newCurrent.index);\n      }\n    },\n    [setCurrentIndex, onRestore, setScenes]\n  );\n\n  const currentScene =\n    currentIndex !== undefined && currentIndex < scenes.length\n      ? { ...scenes[currentIndex], drawing }\n      : undefined;\n\n  let requiredWidth: number | undefined;\n  let requiredHeight: number | undefined;\n  if (currentScene != null && scenes.length !== 1) {\n    requiredWidth = currentScene.width;\n    requiredHeight = currentScene.height;\n  }\n\n  useEffect(() => {\n    if (currentIndex != null && drawing) {\n      const scene = createScene(\n        drawing,\n        requiredWidth === undefined || requiredHeight === undefined\n          ? undefined\n          : {\n              width: requiredWidth,\n              height: requiredHeight,\n            }\n      );\n      if (scene) {\n        updateScenes((prev) => {\n          const result = [...prev];\n          result[currentIndex] = scene;\n          return result;\n        }, undefined);\n      }\n    }\n  }, [\n    drawing,\n    currentIndex,\n    scenes.length,\n    updateScenes,\n    requiredWidth,\n    requiredHeight,\n  ]);\n\n  const addScene = useCallback(() => {\n    if (drawing) {\n      const scene = createScene(\n        drawing,\n        scenes[0] && {\n          width: scenes[0].width,\n          height: scenes[0].height,\n        }\n      );\n      if (scene) {\n        updateScenes((prev) => [...prev, scene], {\n          index: scenes.length,\n          drawing: drawing,\n        });\n      }\n    }\n  }, [updateScenes, scenes, drawing]);\n\n  return {\n    initialised,\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    scenes,\n    updateScenes,\n    initialData: drawing,\n  };\n};\n","import React, { useRef } from \"react\";\nimport Excalidraw from \"@excalidraw/excalidraw\";\nimport type { ExcalidrawAPIRefValue } from \"@excalidraw/excalidraw/types/types\";\nimport type { ExcalidrawImperativeAPI } from \"@excalidraw/excalidraw/types/components/App\";\nimport \"./App.css\";\nimport Claymate from \"./Claymate\";\nimport { Drawing } from \"./types\";\nimport { useScenes } from \"./useScenes\";\n\nconst App: React.FC = () => {\n  const excalidrawRef = useRef<ExcalidrawAPIRefValue>(null);\n  const updateDrawing = (drawing: Drawing) => {\n    (excalidrawRef.current as ExcalidrawImperativeAPI | null)?.updateScene(\n      drawing\n    );\n  };\n  const {\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    initialData,\n    scenes,\n    updateScenes,\n  } = useScenes();\n\n  return (\n    <div className=\"ClaymateApp\">\n      <Excalidraw\n        ref={excalidrawRef}\n        key={drawingVersion}\n        initialData={initialData}\n        onChange={onChange}\n      />\n      <Claymate\n        scenes={scenes}\n        currentIndex={currentIndex}\n        updateScenes={updateScenes}\n        moveToScene={moveToScene}\n        addScene={addScene}\n        updateDrawing={updateDrawing}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}