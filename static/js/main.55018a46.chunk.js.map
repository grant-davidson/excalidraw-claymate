{"version":3,"sources":["exportToGif.ts","exportToHtml.ts","Claymate.tsx","creation.ts","useScenes.ts","persistence.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["exportToGif","scenes","Promise","resolve","gif","GIF","forEach","scene","index","last","length","addFrame","imageData","delay","on","blob","fileSave","fileName","then","render","exportToHtml","a","html","svg","exportToSvg","drawing","id","style","display","outerHTML","Blob","type","Preview","ref","useRef","useEffect","current","ctx","getContext","putImageData","width","height","Claymate","currentIndex","updateScenes","moveToScene","addScene","exportGif","exportHtml","className","map","key","onClick","aria-label","event","stopPropagation","findIndex","sc","newIndex","remainingScenes","newCurrent","undefined","prev","filter","item","deleteScene","disabled","tmp","moveLeft","moveRight","reverse","createScene","size","canvas","exportToCanvas","elements","nanoid","getImageData","initialScenes","firstScene","drawings","JSON","parse","localStorage","getItem","appState","collaborators","Map","data","e","loadDrawingFromStorage","loadStorage","initialData","useScenes","requiredWidth","requiredHeight","useState","drawingVersion","setDrawingVersion","setCurrentIndex","setScenes","setDrawing","onRestore","useCallback","version","updater","currentScene","result","onChange","isEqual","update","el","updatedScenes","stringify","s","setItem","saveStorage","App","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.55018a46.chunk.js","sourcesContent":["import { fileSave } from \"browser-fs-access\";\n// @ts-ignore\nimport GIF from \"gif.js/dist/gif\";\n\nimport { Scene } from \"./types\";\n\nexport const exportToGif = (scenes: Scene[]) =>\n  new Promise((resolve) => {\n    const gif = new GIF();\n    scenes.forEach((scene, index) => {\n      const last = index + 1 === scenes.length;\n      gif.addFrame(scene.imageData, { delay: last ? 2000 : 500 });\n    });\n    gif.on(\"finished\", (blob: Blob) => {\n      fileSave(blob, {\n        fileName: \"excalidraw-claymate.gif\",\n      }).then(resolve);\n    });\n    gif.render();\n  });\n","import { fileSave } from \"browser-fs-access\";\nimport { exportToSvg } from \"@excalidraw/excalidraw\";\n\nimport { Scene } from \"./types\";\n\nexport const exportToHtml = async (scenes: Scene[]) => {\n  let html = `\n    <html>\n      <style>\n        svg { width: 100%; height: 100%; }\n      </style>\n      <script>\n        let index = 0;\n        document.addEventListener('DOMContentLoaded', () => {\n          document.getElementById('scene' + index).style.display = 'block';\n        });\n        document.addEventListener('keydown', (event) => {\n          if (event.key === 'ArrowRight' && index < ${scenes.length - 1}) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index += 1;\n            document.getElementById('scene' + index).style.display = 'block';\n          }\n          if (event.key === 'ArrowLeft' && index > 0) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index -= 1;\n            document.getElementById('scene' + index).style.display = 'block';\n          }\n          if (event.key.toLowerCase() === \"f\") {\n            if (document.fullscreenElement === document.body) {\n              document.exitFullscreen();\n            } else {\n              document.body.requestFullscreen();\n            }\n          }\n        });\n      </script>\n      <body>\n  `;\n  scenes.forEach((scene, index) => {\n    const svg: SVGSVGElement = exportToSvg(scene.drawing);\n    svg.id = `scene${index}`;\n    svg.style.display = \"none\";\n    html += svg.outerHTML;\n  });\n  html += \"</body></html>\";\n  await fileSave(new Blob([html], { type: \"text/html\" }), {\n    fileName: \"excalidraw-claymate.html\",\n  });\n};\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Claymate.css\";\nimport { Drawing, Scene } from \"./types\";\nimport { exportToGif } from \"./exportToGif\";\nimport { exportToHtml } from \"./exportToHtml\";\n\nconst Preview: React.FC<{ scene: Scene }> = ({ scene }) => {\n  const ref = useRef<HTMLCanvasElement>(null);\n  useEffect(() => {\n    if (!ref.current) return;\n    const ctx = ref.current.getContext(\"2d\");\n    if (!ctx) return;\n    ctx.putImageData(scene.imageData, 0, 0);\n  }, [scene]);\n  return <canvas ref={ref} width={scene.width} height={scene.height} />;\n};\n\ntype Props = {\n  currentIndex: number | undefined;\n  scenes: Scene[];\n  updateScenes: (\n    updater: (prev: Scene[]) => Scene[],\n    newCurrent?: { index: number; drawing: Drawing }\n  ) => void;\n  moveToScene: (index: number) => void;\n  addScene: () => void;\n};\n\nconst Claymate: React.FC<Props> = ({\n  scenes,\n  currentIndex,\n  updateScenes,\n  moveToScene,\n  addScene,\n}) => {\n  const exportGif = async () => {\n    await exportToGif(scenes);\n  };\n\n  const exportHtml = async () => {\n    await exportToHtml(scenes);\n  };\n\n  const deleteScene = (id: string) => {\n    const index = scenes.findIndex((sc) => sc.id === id);\n    if (index >= 0) {\n      const remainingScenes = scenes.length - 1;\n      let newIndex;\n      if (remainingScenes > 0) {\n        newIndex = index < remainingScenes ? index : remainingScenes - 1;\n      }\n      const newCurrent =\n        newIndex !== undefined\n          ? { index: newIndex, drawing: scenes[newIndex].drawing }\n          : undefined;\n\n      updateScenes((prev) => prev.filter((item) => item.id !== id), newCurrent);\n    }\n  };\n\n  const moveLeft = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index - 1] = prev[index];\n        tmp[index] = prev[index - 1];\n        return tmp;\n      },\n      { index: index - 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const moveRight = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index + 1] = prev[index];\n        tmp[index] = prev[index + 1];\n        return tmp;\n      },\n      { index: index + 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const reverseOrder = () => {\n    updateScenes(\n      (prev) => [...prev].reverse(),\n      currentIndex !== undefined\n        ? {\n            index: scenes.length - 1 - currentIndex,\n            drawing: scenes[currentIndex].drawing,\n          }\n        : undefined\n    );\n  };\n\n  useEffect(() => {\n    if (scenes.length === 0) {\n      addScene();\n    }\n  }, [scenes, addScene]);\n\n  return (\n    <div className=\"Claymate\">\n      <div className=\"Claymate-scenes\">\n        {scenes.map((scene, index) => (\n          <div\n            key={scene.id}\n            className={`Claymate-scene ${\n              index === currentIndex ? \"Claymate-current-scene\" : \"\"\n            }`}\n            onClick={() => moveToScene(index)}\n          >\n            <Preview scene={scene} />\n            <button\n              type=\"button\"\n              className=\"Claymate-delete\"\n              aria-label=\"Delete\"\n              onClick={(event) => {\n                event.stopPropagation();\n                deleteScene(scene.id);\n              }}\n            >\n              &#x2716;\n            </button>\n            <button\n              type=\"button\"\n              className=\"Claymate-left\"\n              aria-label=\"Move Left\"\n              disabled={index === 0}\n              onClick={(event) => {\n                event.stopPropagation();\n                moveLeft(scene.id);\n              }}\n            >\n              &#x2b05;\n            </button>\n            <button\n              type=\"button\"\n              className=\"Claymate-right\"\n              aria-label=\"Move Right\"\n              disabled={index === scenes.length - 1}\n              onClick={(event) => {\n                event.stopPropagation();\n                moveRight(scene.id);\n              }}\n            >\n              &#x27a1;\n            </button>\n          </div>\n        ))}\n      </div>\n      <div className=\"Claymate-buttons\">\n        <button type=\"button\" onClick={addScene}>\n          Add scene\n        </button>\n        <button\n          type=\"button\"\n          onClick={exportGif}\n          disabled={scenes.length === 0}\n        >\n          Export GIF\n        </button>\n        <button\n          type=\"button\"\n          onClick={exportHtml}\n          disabled={scenes.length === 0}\n        >\n          Export HTML\n        </button>\n        <button\n          type=\"button\"\n          onClick={reverseOrder}\n          disabled={scenes.length <= 1}\n        >\n          Reverse order\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Claymate;\n","import { nanoid } from \"nanoid\";\nimport { exportToCanvas } from \"@excalidraw/excalidraw\";\nimport { Drawing, Scene } from \"./types\";\n\nexport const createScene = (\n  drawing: Drawing,\n  size?: { width: number; height: number }\n): Scene | undefined => {\n  const canvas = exportToCanvas({ elements: drawing.elements });\n  const width = size ? size.width : canvas.width;\n  const height = size ? size.height : canvas.height;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    return {\n      id: nanoid(),\n      width,\n      height,\n      imageData: ctx.getImageData(0, 0, width, height),\n      drawing,\n    };\n  }\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { AppState } from \"@excalidraw/excalidraw/types/types\";\nimport { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\nimport isEqual from \"lodash/isEqual\";\nimport { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\nimport { loadStorage, saveStorage } from \"./persistence\";\n\nlet initialScenes = loadStorage();\nlet initialData =\n  initialScenes && initialScenes.length > 0\n    ? initialScenes[0].drawing\n    : undefined;\n\nexport const useScenes = () => {\n  const [drawingVersion, setDrawingVersion] = useState(0);\n  const [currentIndex, setCurrentIndex] = useState<number | undefined>(\n    initialScenes ? 0 : undefined\n  );\n  const [scenes, setScenes] = useState<Scene[]>(initialScenes || []);\n  const [drawing, setDrawing] = useState<Drawing | undefined>(\n    initialScenes ? initialScenes[0].drawing : undefined\n  );\n\n  const onRestore = useCallback((drawing: Drawing) => {\n    setDrawingVersion((version) => version + 1);\n    initialData = drawing;\n  }, []);\n\n  const moveToScene = useCallback(\n    (index: number) => {\n      onRestore(scenes[index].drawing);\n      setCurrentIndex(index);\n    },\n    [onRestore, setCurrentIndex, scenes]\n  );\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState\n  ) => {\n    if (\n      drawing == null ||\n      !isEqual(elements, drawing.elements) ||\n      !isEqual(appState, drawing.appState)\n    ) {\n      const update = {\n        elements: elements.map((el) => {\n          return { ...(el as any) };\n        }),\n        appState: { ...(appState as any) },\n      };\n      setDrawing(update);\n      if (currentIndex !== undefined) {\n        const updatedScenes = [...scenes];\n        updatedScenes[currentIndex] = {\n          ...updatedScenes[currentIndex],\n          drawing: update,\n        };\n        saveStorage(updatedScenes);\n      }\n    }\n  };\n\n  const updateScenes = useCallback(\n    (\n      updater: (prev: Scene[]) => Scene[],\n      newCurrent?: { index: number; drawing: Drawing }\n    ) => {\n      setScenes(updater);\n      if (newCurrent) {\n        onRestore(newCurrent.drawing);\n        setCurrentIndex(newCurrent.index);\n      }\n    },\n    [setCurrentIndex, onRestore, setScenes]\n  );\n\n  const currentScene =\n    currentIndex !== undefined && currentIndex < scenes.length\n      ? { ...scenes[currentIndex], drawing }\n      : undefined;\n\n  let requiredWidth: number | undefined;\n  let requiredHeight: number | undefined;\n  if (currentScene != null && scenes.length !== 1) {\n    requiredWidth = currentScene.width;\n    requiredHeight = currentScene.height;\n  }\n\n  useEffect(() => {\n    if (currentIndex != null && drawing) {\n      const scene = createScene(\n        drawing,\n        requiredWidth === undefined || requiredHeight === undefined\n          ? undefined\n          : {\n              width: requiredWidth,\n              height: requiredHeight,\n            }\n      );\n      if (scene) {\n        updateScenes((prev) => {\n          const result = [...prev];\n          result[currentIndex] = scene;\n          return result;\n        }, undefined);\n      }\n    }\n  }, [\n    drawing,\n    currentIndex,\n    scenes.length,\n    updateScenes,\n    requiredWidth,\n    requiredHeight,\n  ]);\n\n  const addScene = useCallback(() => {\n    if (drawing) {\n      const scene = createScene(\n        drawing,\n        scenes[0] && {\n          width: scenes[0].width,\n          height: scenes[0].height,\n        }\n      );\n      if (scene) {\n        updateScenes((prev) => [...prev, scene], {\n          index: scenes.length,\n          drawing: drawing,\n        });\n      }\n    }\n  }, [updateScenes, scenes, drawing]);\n\n  return {\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    scenes,\n    updateScenes,\n    initialData,\n  };\n};\n","import { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\n\nconst ELEMENTS_STORAGE_KEY = \"excalidraw-elements\";\nconst SCENE_STORAGE_KEY = \"claymate-scenes\";\n\nconst loadDrawingFromStorage = (): Drawing | null => {\n  try {\n    const data = JSON.parse(localStorage.getItem(ELEMENTS_STORAGE_KEY) || \"\");\n    data.appState.collaborators = new Map();\n    return data;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const loadStorage = (): Scene[] | null => {\n  try {\n    const drawings = JSON.parse(\n      localStorage.getItem(SCENE_STORAGE_KEY) || \"\"\n    ) as Drawing[];\n    if (drawings && drawings.length > 0) {\n      let firstScene: Scene | undefined;\n      return drawings.map((drawing) => {\n        drawing.appState.collaborators = new Map();\n        const scene = createScene(\n          drawing,\n          firstScene\n            ? { width: firstScene.width, height: firstScene.height }\n            : undefined\n        );\n        if (firstScene === undefined) {\n          firstScene = scene;\n        }\n        return scene;\n      }) as Scene[];\n    }\n  } catch {\n    try {\n      const drawing = loadDrawingFromStorage();\n      if (drawing) {\n        const scene = createScene(drawing);\n        if (scene) {\n          return [scene];\n        }\n      }\n    } catch {}\n  }\n  return null;\n};\n\nexport const saveStorage = (scenes: Scene[]) => {\n  const result = JSON.stringify(scenes.map((s) => s.drawing));\n  localStorage.setItem(SCENE_STORAGE_KEY, result);\n};\n","import React from \"react\";\nimport Excalidraw from \"@excalidraw/excalidraw\";\nimport \"./App.css\";\nimport Claymate from \"./Claymate\";\nimport { useScenes } from \"./useScenes\";\n\nconst App: React.FC = () => {\n  const {\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    initialData,\n    scenes,\n    updateScenes,\n  } = useScenes();\n\n  return (\n    <div className=\"ClaymateApp\">\n      <Excalidraw\n        key={drawingVersion}\n        initialData={initialData}\n        onChange={onChange}\n      />\n      <Claymate\n        scenes={scenes}\n        currentIndex={currentIndex}\n        updateScenes={updateScenes}\n        moveToScene={moveToScene}\n        addScene={addScene}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}